# Chapter 2: 데이터 모델과 질의 언어

범용 데이터 모델을 훑어보는 장. 크게 **관계형 모델**, **문서형 모델**, **그래프 기반 데이터 모델**을 다룬다.

---

## 1. 관계형 모델

### 1-1. 핵심 개념

- **관계(테이블)**: 순서 없는 튜플(로우)의 모음
  - 테이블은 행들의 집합이며, 행들이 입력된 순서나 저장된 물리적 위치는 데이터의 본질적인 의미에 영향을 주지 않는다.
- **목표**: 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것 (추상화)
- 웹에서 사용되는 대부분의 서비스에서 사용 중

### 1-2. NoSQL

- **Not Only SQL**의 약자
- 등장 배경:
  - 매우 높은 쓰기 처리량을 감당하기 위한 모델 구조 필요
  - 정형화되지 않은 자유롭고 풍부한 표현력을 가진 데이터 모델에 대한 수요
  - 확장성이 좋음
  - 무료 오픈소스 소프트웨어에 대한 선호도 확산
  - 관계형 모델에서 지원하지 않는 특수 질의 동작

### 1-3. 임피던스 불일치 (Impedance Mismatch)

- 객체지향 언어와 SQL 모델 간의 불일치로 인해 발생하는 불편함
- **RDBMS 방식**: 데이터를 정규화하여 여러 테이블로 분리하고, 외래키와 JOIN을 통해 연결
- **객체지향 방식**: 객체를 중첩 구조와 직접 참조로 표현
- 이 두 방식이 충돌함
- 임피던스 불일치를 줄이기 위해 **JSON 모델**을 선호하는 경우가 있음
  - **지역성(Locality)**: 시간적(캐싱), 공간적(실제 저장위치)으로 가까움

### 1-4. 다대일과 다대다 관계

- 데이터는 애플리케이션에 기능이 추가될수록 상호 연결되는 경향이 있다.
- 중복된 데이터를 정규화하려면 **다대일**, **다대다** 관계가 필요함
- **JOIN**을 사용해 필요한 관계들을 연결하여 복합적인 데이터를 표현함
- JOIN이 구현되어 있지 않은 데이터베이스는 사용성이 나쁠 수밖에 없다.

---

## 2. 문서 데이터베이스

### 2-1. 역사적 배경

- **1968년 IBM 정보관리 시스템(IMS)**이 최초의 데이터베이스 시스템
- **계층 모델** 사용 (JSON 모델과 비슷함)
  - 모든 데이터를 레코드 내의 중첩된 레코드 트리로 표현
  - 트리 구조에서 모든 레코드는 정확히 하나의 부모를 가짐

### 2-2. 계층 모델의 특징

- **장점**:
  - 일대다 관계나 레코드 간 관계가 없이 독립적일 때 좋은 모델
  - 일대다 관계에서는 문제 없음
- **단점**:
  - 다대다 관계 표현이 어려움
  - JOIN이 없음
- 이를 보완하기 위해 **관계형 모델**과 **네트워크 모델**이 등장

### 2-3. 문서 모델의 특징

- 관계형 모델의 외래키처럼 **'문서 참조'**라는 고유한 식별자를 사용해 다대일, 다대다 관계를 표현
- **장점**:
  - 관계형 모델보다 성능이 더 좋음 (스키마 유연성, 지역성)
  - 애플리케이션 중 문서형 모델과 데이터 구조가 비슷한 경우에 적합
  - 일대다 관계 트리로 한 번에 전체 트리를 적재하는 경우에 사용하면 좋음
  - **읽기 스키마(Schema-on-Read)**: 데이터 구조가 암묵적, 일단 저장한 뒤에 필요할 때 꺼내서 읽음
  - 데이터 타입 변경이 쉬움 (변경 이전과 이후를 구분하는 분기점 세팅)
  - 테이블로 관리할 수 있는 오브젝트의 종류가 많을 때 유리 (UNION 등의 복잡하고 부하를 많이 주는 로직에 의존할 필요가 없어짐)
- **단점**:
  - 문서 내 중첩 항목은 바로 참조할 수 없어서 상위 레코드에서 타고 들어가야 함
  - 조인이 없어서 다대다 관계를 애플리케이션 레벨에서 구현해야 함

### 2-4. 네트워크 모델 (코다실 모델)

- 계층 모델의 일반화 추구
- **특징**:
  - 레코드가 다중 부모를 가질 수 있음 → 다대일, 다대다 관계 표현 가능
- **단점**:
  - 계층 구조이기 때문에 접근 경로를 찾아 최상위 레코드에서부터 내려가면서 찾아야 해 비효율적
  - 다대다 관계에서는 시간 복잡도 O(n)
  - 접근 경로를 변경해야 하거나 훼손된 상태면 코드 단계에서부터 일일이 디버깅해야 하는 어려움 존재

### 2-5. 관계형 모델과의 비교

| 구분 | 관계형 모델 | 문서 모델 |
|------|------------|----------|
| 스키마 | **쓰기 스키마(Schema-on-Write)**: 데이터가 작성되는 스키마를 명시 | **읽기 스키마(Schema-on-Read)**: 데이터 구조가 암묵적 |
| 데이터 타입 변경 | 마이그레이션 필요 (스키마 변경 → 느림) | 쉬움 (분기점 세팅) |
| 구조 | 평평한 구조, 중첩 구조와 접근 경로 없음 | 중첩된 트리 구조 |
| 조인 | JOIN 지원, 다대일/다대다 관계 표현 쉬움 | JOIN 없음, 애플리케이션에서 처리 |
| 질의 최적화 | 질의 최적화기가 자동으로 실행 방식 결정 | - |

### 2-6. 저장소 지역성과 권장 사항

- JSON 형식은 문서 데이터에 특정 스키마를 강요하지 않음
- 애플리케이션이 자주 전체 문서(혹은 많은 부분)에 접근해야 할 때는 **저장소 지역성** 개념을 활용하는 것이 좋음
- DB는 문서의 작은 부분에 접근해도 문서 전체를 적재해야 하기에 문서 크기가 클 경우 문제가 될 수 있음
  - **권장**: 문서(레코드)를 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피할 것
- 관계형과 문서의 **혼합 모델**은 긍정적인 방향성
- 2000년대 중반 이후 관계형 모델에서도 XML/JSON 형식이 지원되기 시작하면서 애플리케이션의 데이터 모델과 호환성을 맞출 수 있게 됨

---

## 3. 데이터를 위한 질의 언어

### 3-1. 선언형 vs 명령형

- **SQL**: 선언형 질의 언어
- **IMS/코다실**: 명령형(코드의 로직) 질의 언어

### 3-2. 선언형 질의의 장점

- 필요한 데이터의 형태(조건, 형태)를 선언하면 애플리케이션 내부 로직이 처리함 (개발자 개입 X)
- 해당 로직의 일반화와 최적화에 집중했던, 뛰어난 개발자들의 지식을 빌려 쓰는 느낌

---

## 4. 맵리듀스 질의

- 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 **프로그래밍 모델**
- Google에서 개발
- **map**, **reduce** 고차 함수 사용

### 4-1. MongoDB의 맵리듀스

- 어느 정도 추상화는 되어 있지만, map과 reduce의 내부 함수를 직접 구현해야 하기 때문에 **명령형에 가까움**
- 이를 보완하기 위해 **집계 파이프라인(Aggregation Pipeline)**이라는 완전 선언형 질의 기능을 만듦

---

## 5. 그래프형 데이터 모델

### 5-1. 개요

- **사용 시점**: 다대다 관계가 너무 많아서 관계형 모델로도 데이터 모델을 구현할 수 없는 경우
- 구성 요소:
  - **정점(Vertex)**: 노드, 엔티티 - 문서나 레코드에 해당
  - **간선(Edge)**: 관계, 호 - 테이블에 해당

### 5-2. 그래프 모델의 특징

- 간선을 물리적인 포인터로 저장 (디스크 상의 물리적 주소가 간선에 직접 저장됨)
- 정점도 NoSQL처럼 레코드의 타입이 고정되지 않음
- 하나의 그래프 안에 **여러 유형의 정점과 간선**을 포함할 수 있음
- 데이터 유형에 따른 레이블 관리를 적절하게 한다면 단일 그래프에 서로 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있음
- **관계의 깊이가 깊어질수록** 관계형 모델에 비해 월등히 좋은 성능을 발휘함
- 관계형 모델도 `WITH RECURSIVE`를 이용해 간선 순회 질의를 구현할 수 있지만 매우 어렵고 비효율적
  - 예: 그래프형 데이터 모델 4줄 vs 관계형 모델 29줄

### 5-3. 속성 그래프 (Property Graph)

**정점의 구성 요소:**
- 고유한 식별자
- 유출 간선 집합
- 유입 간선 집합
- 속성 컬렉션 (키-값 쌍)

**간선의 구성 요소:**
- 고유한 식별자
- 간선이 시작하는 정점 (꼬리 정점)
- 간선이 끝나는 정점 (머리 정점)
- 두 정점 간 관계 유형을 설명하는 **레이블** (관계형 모델의 테이블명 역할)
  - 예: `(Idaho)-[:WITHIN]->(USA)-[:WITHIN]->(NAmerica)`
- 속성 컬렉션 (키-값 쌍)

### 5-4. 사이퍼 (Cypher)

- **선언형 질의 언어**
- Neo4j 그래프 데이터베이스 용

### 5-5. 트리플 저장소와 스파클 (SPARQL)

- 속성 그래프 모델과 유사
- 모든 정보를 **'주어/서술어/목적어'**와 같은 세 부분 구문 형식으로 저장
  - 주어와 목적어는 모두 **정점**
  - 서술어는 **간선**
- 세미콜론을 이용해 데이터를 깔끔하게 작성할 수 있음 (같은 주어일 경우 한 번만 표현해도 됨)

### 5-6. 시멘틱 웹 (Semantic Web)

- 웹 사이트가 기계도 읽을 수 있도록 데이터를 게시하게 하는 개념
- **자원 기술 프레임워크(RDF)**: 서로 다른 웹사이트가 일관된 형식으로 데이터를 게시하기 위한 방법
- 과대평가된 경향이 있던 개념, 실용화되지 못함

### 5-7. 스파클 질의 언어 (SPARQL)

- RDF 데이터 모델을 사용한 트리플 저장소 질의 언어
- 사이퍼의 패턴 매칭 방식을 스파클에서 차용했기 때문에 사이퍼 그래프 모델과 비슷한 성격을 지님

### 5-8. 데이터로그 (Datalog)

- 스파클, 사이퍼보다 더 오래된 언어
- **핵심 포인트**:
  - 데이터 구성: `서술어(주어, 목적어)`
  - **규칙(Rule)**: 기존의 주어, 목적어를 조합해 새로운 사실을 유도하는 논리
  - 규칙은 재귀적으로 자신, 혹은 다른 규칙을 계속 참조할 수 있음
